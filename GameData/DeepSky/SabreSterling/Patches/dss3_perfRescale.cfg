// Insert SD node with desired parameter into target parts if and after Sigma Dimensions
@PART[dss?_sabre*|dss?_nacelle*]:AFTER[SigDim2]
{
	#@SigmaDimensions {}
	@SigmaDimensions
	{
		!Resize = del
		!Atmosphere = del
		!dayLengthMultiplier = del
		!landscape = del
		!groundTiling = del
		!atmoASL = del
		!tempASL = del
		!atmoTopLayer = del
		!atmoVisualEffect = del
		!lightRange = del
		!scanAltitude = del
		!geeASLmultiplier = del
		!resizeScatter = del
		!CustomSoISize = del
		!CustomRingSize = del
		!reEntryHeat = del
		!resizeBuildings = del
	}
}

// Modify part(s) once they have this node and if the node has matching value
// This pass seems to not like targeting non-integer values

// Will respond to 3.2x scale and above
@PART[dss2_sabre|dss2_sabre_ram|dss3_sabre|dss3_sabre_ram]:HAS[@SigmaDimensions:HAS[#Rescale[>3]]]:AFTER[SigDim2]
{
	@MODULE[ModuleEnginesFX]:HAS[#engineID[AirBreathing]]
	{
		@velCurve
		{
			!key,* = nope
			key = 0 1 0 0.08333334
			key = 0.2 0.98 0.42074 0.42074
			key = 0.7 1.8 2.290406 2.290406
			key = 2.2 4 3.887193 3.887193
			key = 4 8.5 0 0
			key = 5.5 7.3 -2.831749 -2.831749
			key = 7 3 -5.260566 -5.260566
			key = 8 0 -0.02420209 0
		}
	}
}

// Respond to 2.5x, 3.2x. Integers only
@PART[dss*_nacelle*]:HAS[@SigmaDimensions:HAS[#Rescale[>2],#Rescale[<6]]]:AFTER[SigDim2]
{
	@MODULE[ModuleResourceConverter]
	{
		@INPUT_RESOURCE:HAS[#ResourceName[IntakeAir]]
		{
			@Ratio /= 2
		}
	}
}

// Respond to 6.4x and above
@PART[dss*_nacelle*]:HAS[@SigmaDimensions:HAS[#Rescale[>6]]]:AFTER[SigDim2]
{
	@MODULE[ModuleResourceConverter]
	{
		@INPUT_RESOURCE:HAS[#ResourceName[MillPower]]
		{
			@Ratio /= 2
		}
		@INPUT_RESOURCE:HAS[#ResourceName[IntakeAir]]
		{
			@Ratio /= 3
		}
	}
}